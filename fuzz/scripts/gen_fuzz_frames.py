#!/usr/bin/env python3
"""
Generate frame wrapper bytes for fuzz targets using scapy.

This script generates Rust const declarations containing raw packet bytes
that can be included in fuzz targets. Using scapy ensures the headers are
valid and correctly formatted.

Usage:
    uvx --with scapy python3 fuzz/scripts/gen_fuzz_frames.py > fuzz/src/frames.rs

Requirements:
    pip install scapy (or use uvx --with scapy)
"""

from scapy.all import Ether, IP, IPv6, UDP, TCP, raw


def generate_frame_header(name: str, pkt, comment: str = "") -> str:
    """Generate a Rust const declaration for a packet's bytes."""
    data = raw(pkt)
    hex_bytes = ", ".join(f"0x{b:02x}" for b in data)
    size_comment = f" // {len(data)} bytes"
    if comment:
        size_comment += f": {comment}"
    return f"pub const {name}: &[u8] = &[{hex_bytes}];{size_comment}"


def main():
    print("// Auto-generated frame wrappers for fuzz targets.")
    print("// Generated by: fuzz/scripts/gen_fuzz_frames.py")
    print("//")
    print("// These constants contain protocol header bytes that fuzz targets")
    print("// use to wrap fuzz data, ensuring the target protocol parser is invoked.")
    print("//")
    print("// To regenerate:")
    print("//   uvx --with scapy python3 fuzz/scripts/gen_fuzz_frames.py > fuzz/src/frames.rs")
    print()

    frames = [
        # DNS: Ethernet + IPv4 + UDP(dst=53)
        # Offsets: IP total_len at 16-17, UDP len at 38-39
        (
            "DNS_FRAME",
            Ether(src="00:00:00:00:00:02", dst="00:00:00:00:00:01") /
            IP(src="10.0.0.1", dst="10.0.0.2", proto=17) /
            UDP(sport=12345, dport=53),
            "Eth(14)+IP(20)+UDP(8)"
        ),

        # ICMP: Ethernet + IPv4(proto=1)
        # Offset: IP total_len at 16-17
        (
            "ICMP_FRAME",
            Ether(src="00:00:00:00:00:02", dst="00:00:00:00:00:01") /
            IP(src="10.0.0.1", dst="10.0.0.2", proto=1),
            "Eth(14)+IP(20)"
        ),

        # ICMPv6: Ethernet + IPv6(nh=58)
        # Offset: IPv6 payload_len at 18-19
        (
            "ICMPV6_FRAME",
            Ether(src="00:00:00:00:00:02", dst="00:00:00:00:00:01", type=0x86DD) /
            IPv6(src="::1", dst="::1", nh=58),
            "Eth(14)+IPv6(40)"
        ),

        # TLS: Ethernet + IPv4 + TCP(dst=443)
        # Offset: IP total_len at 16-17
        (
            "TLS_FRAME",
            Ether(src="00:00:00:00:00:02", dst="00:00:00:00:00:01") /
            IP(src="10.0.0.1", dst="10.0.0.2", proto=6) /
            TCP(sport=12345, dport=443, flags="PA", seq=1),
            "Eth(14)+IP(20)+TCP(20)"
        ),

        # BGP: Ethernet + IPv4 + TCP(dst=179)
        # For potential refactoring of existing P1 targets
        (
            "BGP_FRAME",
            Ether(src="00:00:00:00:00:02", dst="00:00:00:00:00:01") /
            IP(src="10.0.0.1", dst="10.0.0.2", proto=6) /
            TCP(sport=12345, dport=179, flags="PA", seq=1),
            "Eth(14)+IP(20)+TCP(20)"
        ),

        # GTP-U: Ethernet + IPv4 + UDP(dst=2152)
        (
            "GTP_U_FRAME",
            Ether(src="00:00:00:00:00:02", dst="00:00:00:00:00:01") /
            IP(src="10.0.0.1", dst="10.0.0.2", proto=17) /
            UDP(sport=2152, dport=2152),
            "Eth(14)+IP(20)+UDP(8)"
        ),

        # GTP-C: Ethernet + IPv4 + UDP(dst=2123)
        (
            "GTP_C_FRAME",
            Ether(src="00:00:00:00:00:02", dst="00:00:00:00:00:01") /
            IP(src="10.0.0.1", dst="10.0.0.2", proto=17) /
            UDP(sport=2123, dport=2123),
            "Eth(14)+IP(20)+UDP(8)"
        ),

        # OSPF: Ethernet + IPv4(proto=89)
        (
            "OSPF_FRAME",
            Ether(src="00:00:00:00:00:02", dst="00:00:00:00:00:01") /
            IP(src="10.0.0.1", dst="224.0.0.5", proto=89),
            "Eth(14)+IP(20)"
        ),

        # GRE: Ethernet + IPv4(proto=47)
        (
            "GRE_FRAME",
            Ether(src="00:00:00:00:00:02", dst="00:00:00:00:00:01") /
            IP(src="10.0.0.1", dst="10.0.0.2", proto=47),
            "Eth(14)+IP(20)"
        ),

        # VXLAN: Ethernet + IPv4 + UDP(dst=4789)
        (
            "VXLAN_FRAME",
            Ether(src="00:00:00:00:00:02", dst="00:00:00:00:00:01") /
            IP(src="10.0.0.1", dst="10.0.0.2", proto=17) /
            UDP(sport=12345, dport=4789),
            "Eth(14)+IP(20)+UDP(8)"
        ),
    ]

    for name, pkt, comment in frames:
        print(generate_frame_header(name, pkt, comment))
        print()


if __name__ == "__main__":
    main()
